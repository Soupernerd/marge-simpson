#!/usr/bin/env bash
# shellcheck disable=SC2015  # A && B || C pattern is intentional for fallback
# shellcheck disable=SC2155  # Declare and assign combined is acceptable here
# shellcheck disable=SC1090  # Can't follow non-constant source (dynamic config)
# shellcheck disable=SC2034  # Some variables reserved for future use (AUTO, FAST)
set -eo pipefail

# ============================================
# Marge v1.1.3 - Autonomous AI Coding Loop
# ============================================

MARGE_HOME="${MARGE_HOME:-$HOME/.marge}"
VERSION="1.1.3"

# Defaults
DRY_RUN=false
VERBOSE=false
MODEL=""
FAST=false
LOOP=false
AUTO=false
MAX_ITER=${MAX_ITER:-20}
MAX_RETRIES=${MAX_RETRIES:-3}
RETRY_DELAY=${RETRY_DELAY:-5}
AUTO_COMMIT=false
ENGINE="claude"
BRANCH_PER_TASK=false
CREATE_PR=false
PARALLEL=false
MAX_PARALLEL=${MAX_PARALLEL:-3}
PRD_FILE="PRD.md"
MARGE_FOLDER="${MARGE_FOLDER:-.marge}"
FULL_MODE=false

# State
iteration=0
total_input_tokens=0
total_output_tokens=0
session_start_time=$(date +%s)
PROGRESS_FILE=".marge/progress.txt"
CONFIG_FILE=".marge/config.yaml"

# Colors
if [[ -t 1 ]] && command -v tput &>/dev/null; then
    RED=$(tput setaf 1 2>/dev/null) || RED=""
    GREEN=$(tput setaf 2 2>/dev/null) || GREEN=""
    YELLOW=$(tput setaf 3 2>/dev/null) || YELLOW=""
    BLUE=$(tput setaf 4 2>/dev/null) || BLUE=""
    CYAN=$(tput setaf 6 2>/dev/null) || CYAN=""
    BOLD=$(tput bold 2>/dev/null) || BOLD=""
    RESET=$(tput sgr0 2>/dev/null) || RESET=""
else
    RED="" GREEN="" YELLOW="" BLUE="" CYAN="" BOLD="" RESET=""
fi

log_info() { echo "${BLUE}[INFO]${RESET} $*"; }
log_success() { echo "${GREEN}[OK]${RESET} $*"; }
log_warn() { echo "${YELLOW}[WARN]${RESET} $*"; }
log_error() { echo "${RED}[ERROR]${RESET} $*" >&2; }
# shellcheck disable=SC2015  # Intentional: || true ensures function always succeeds
log_debug() { [[ "$VERBOSE" == true ]] && echo "[DEBUG] $*" || true; }

print_usage() {
    cat <<EOF
${BOLD}marge${RESET} v$VERSION - Autonomous AI coding loop

${BOLD}USAGE:${RESET}
  marge [options]                    Run PRD tasks from PRD.md
  marge "<task>" [options]           Run a single task
  marge "<task1>" "<task2>" ...      Chain multiple tasks

${BOLD}EXAMPLES:${RESET}
  marge "fix the login bug"
  marge "say hello" "what is 2+2"    # Chain multiple one-off tasks
  marge --full "complex refactor"    # Use full AGENTS.md for one-off
  marge --loop --auto
  marge --parallel --max-parallel 3
  marge --engine aider --loop

${BOLD}ONE-OFF TASKS:${RESET}
  When no local .marge/ folder exists, marge runs in "lite" mode:
  - Minimal prompt, lower token cost
  - No tracking files created
  - Use --full to enable full AGENTS.md workflow

${BOLD}OPTIONS:${RESET}
  --auto              Auto-approve for non-claude engines
  --dry-run           Preview without running
  --model <model>     Model override
  --fast              Skip verification
  --full              Use full global AGENTS.md (instead of lite mode)
  --loop              Loop until complete
  --engine <e>        Engine: claude, opencode, codex, aider
  --max-iterations N  Max iterations (default: $MAX_ITER)
  --max-retries N     Max retries per task (default: $MAX_RETRIES)
  --commit            Auto-commit changes after task
  --no-commit         Disable auto-commit (default)
  --parallel          Run tasks in parallel using git worktrees
  --max-parallel N    Max parallel agents (default: $MAX_PARALLEL)
  --branch-per-task   Create branch per task
  --create-pr         Create PR when done
  --folder <dir>      Target folder (default: .marge)
  -v, --verbose       Verbose output
  --version           Show version
  --help              Show help

${BOLD}COMMANDS:${RESET}
  init [--force]      Initialize .marge/ folder (--force to overwrite)
  clean               Remove local .marge/ folder (won't touch global install)
  meta "<task>"       Run task using .marge/meta folder (for self-development)
  status              Show current status and progress
  config              Show config file contents
  resume              Resume from saved progress

${BOLD}CONFIG FILE:${RESET}
  Place .marge/config.yaml in your project:
    engine: claude
    model: ""
    max_iterations: 20
    max_retries: 3
    auto_commit: false

${BOLD}PRD FORMAT:${RESET}
  Tasks are parsed from PRD.md using "### Task N: Title" format.
  See 'marge init' for a template.
EOF
}

slugify() {
    # shellcheck disable=SC2001  # sed needed for regex patterns not supported by bash substitution
    echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-|-$//g' | cut -c1-50
}

# shellcheck disable=SC2015  # Intentional: || true ensures optional notifications don't fail
notify_done() {
    local msg="${1:-Marge complete}"
    command -v notify-send &>/dev/null && notify-send "Marge" "$msg" 2>/dev/null || true
    [[ "$(uname)" == "Darwin" ]] && command -v osascript &>/dev/null && \
        osascript -e "display notification \"$msg\" with title \"Marge\"" 2>/dev/null || true
}

show_spinner() {
    local output_file="$1"
    local task="$2"
    local pid="$3"
    local start_time
    start_time=$(date +%s)
    local spinstr='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local spin_idx=0
    local current_step="Working"

    # Marge hair blue and Simpsons yellow (24-bit color)
    local MARGE_BLUE=$'\033[38;2;98;154;211m'
    local SIMPSONS_YELLOW=$'\033[38;2;255;217;15m'
    local RESET_COLOR=$'\033[0m'

    task="${task:0:45}..."

    # Ensure we have a TTY
    [[ -t 1 ]] || return 0

    while kill -0 "$pid" 2>/dev/null; do
        local elapsed=$(($(date +%s) - start_time))
        local mins=$((elapsed / 60))
        local secs=$((elapsed % 60))

        # Check output for step indicators (less frequently to reduce overhead)
        if (( spin_idx % 5 == 0 )) && [[ -f "$output_file" ]] && [[ -s "$output_file" ]]; then
            local content
            content=$(tail -c 3000 "$output_file" 2>/dev/null) || true

            if [[ "$content" == *"git commit"* ]]; then
                current_step="Committing"
            elif [[ "$content" == *"git add"* ]]; then
                current_step="Staging"
            elif [[ "$content" == *lint* ]] || [[ "$content" == *eslint* ]] || [[ "$content" == *biome* ]]; then
                current_step="Linting"
            elif [[ "$content" == *'"tool":"Bash"'* ]] && [[ "$content" == *test* ]]; then
                current_step="Testing"
            elif [[ "$content" == *'"tool":"Write"'* ]] || [[ "$content" == *'"tool":"Edit"'* ]]; then
                current_step="Writing"
            elif [[ "$content" == *'"tool":"Read"'* ]] || [[ "$content" == *'"tool":"Glob"'* ]]; then
                current_step="Reading"
            elif [[ "$content" == *hinking* ]]; then
                current_step="Thinking"
            fi
        fi

        local spinner_char="${spinstr:$spin_idx:1}"

        # Clear line and print - use \r for carriage return, \033[K for clear to end
        printf '\r\033[K  %s%s%s %s%s%s [%02d:%02d] %s' \
            "$MARGE_BLUE" "$spinner_char" "$RESET_COLOR" \
            "$SIMPSONS_YELLOW" "$current_step" "$RESET_COLOR" \
            "$mins" "$secs" "$task"

        spin_idx=$(( (spin_idx + 1) % ${#spinstr} ))
        sleep 0.1
    done

    # Clear line
    printf '\r\033[K' 2>/dev/null
}

load_config() {
    [[ ! -f "$CONFIG_FILE" ]] && return 0

    while IFS='=' read -r key value; do
        [[ -z "$key" || "$key" =~ ^# ]] && continue
        key=${key// /}
        value=${value// /}
        value=${value//\"/}
        value=${value%%#*}

        case "$key" in
            engine) [[ -z "$ENGINE" || "$ENGINE" == "claude" ]] && ENGINE="$value" ;;
            model) [[ -z "$MODEL" ]] && MODEL="$value" ;;
            max_iterations) MAX_ITER="$value" ;;
            max_retries) MAX_RETRIES="$value" ;;
            auto_commit) AUTO_COMMIT="$value" ;;
        esac
    done < <(grep -v '^#' "$CONFIG_FILE" | tr ':' '=' 2>/dev/null)
}

save_progress() {
    mkdir -p .marge
    cat > "$PROGRESS_FILE" <<EOF
iteration=$iteration
task_index=${1:-0}
timestamp=$(date +%s)
status=${2:-running}
EOF
}

load_progress() {
    [[ ! -f "$PROGRESS_FILE" ]] && return 1
    # shellcheck disable=SC1090  # Dynamic source file for progress state
    source "$PROGRESS_FILE" 2>/dev/null || return 1
    return 0
}

clear_progress() {
    rm -f "$PROGRESS_FILE" 2>/dev/null
}

detect_project() {
    if [[ -f "package.json" ]]; then
        echo "node"
    elif [[ -f "Cargo.toml" ]]; then
        echo "rust"
    elif [[ -f "go.mod" ]]; then
        echo "go"
    elif [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]]; then
        echo "python"
    elif [[ -f "Gemfile" ]]; then
        echo "ruby"
    else
        echo "unknown"
    fi
}

setup_worktree() {
    local task_slug="$1"
    local worktree_dir=".marge/worktrees/$task_slug"

    if [[ ! -d "$worktree_dir" ]]; then
        git worktree add "$worktree_dir" -b "marge/$task_slug" 2>/dev/null || {
            git worktree add "$worktree_dir" "marge/$task_slug" 2>/dev/null || return 1
        }
    fi
    echo "$worktree_dir"
}

cleanup_worktrees() {
    git worktree prune 2>/dev/null || true
    rm -rf .marge/worktrees 2>/dev/null || true
}

check_engine() {
    case "$1" in
        claude) command -v claude &>/dev/null || { log_error "claude not found"; return 1; } ;;
        opencode) command -v opencode &>/dev/null || { log_error "opencode not found"; return 1; } ;;
        codex) command -v codex &>/dev/null || { log_error "codex not found"; return 1; } ;;
        aider) command -v aider &>/dev/null || { log_error "aider not found"; return 1; } ;;
        *) log_error "Unknown engine: $1"; return 1 ;;
    esac
}

get_token_summary() {
    local output_file="$1"
    local input_tokens=0
    local output_tokens=0

    if [[ -f "$output_file" ]]; then
        # Parse stream-json output for token usage
        # Claude outputs JSON lines, look for usage data in result or usage objects
        # Try multiple patterns since format may vary

        # Pattern 1: "type": "result" with usage nested
        local result_line
        result_line=$(grep -E '"type"\s*:\s*"result"' "$output_file" 2>/dev/null | tail -1) || true

        if [[ -n "$result_line" ]]; then
            input_tokens=$(echo "$result_line" | grep -oE '"input_tokens"\s*:\s*[0-9]+' | grep -oE '[0-9]+' | tail -1) || input_tokens=0
            output_tokens=$(echo "$result_line" | grep -oE '"output_tokens"\s*:\s*[0-9]+' | grep -oE '[0-9]+' | tail -1) || output_tokens=0
        fi

        # Pattern 2: Look for usage object directly if above failed
        if [[ "$input_tokens" -eq 0 ]] && [[ "$output_tokens" -eq 0 ]]; then
            local usage_line
            usage_line=$(grep -E '"usage"\s*:' "$output_file" 2>/dev/null | tail -1) || true
            if [[ -n "$usage_line" ]]; then
                input_tokens=$(echo "$usage_line" | grep -oE '"input_tokens"\s*:\s*[0-9]+' | grep -oE '[0-9]+' | tail -1) || input_tokens=0
                output_tokens=$(echo "$usage_line" | grep -oE '"output_tokens"\s*:\s*[0-9]+' | grep -oE '[0-9]+' | tail -1) || output_tokens=0
            fi
        fi

        # Pattern 3: Check for total_tokens as fallback
        if [[ "$input_tokens" -eq 0 ]] && [[ "$output_tokens" -eq 0 ]]; then
            local total
            total=$(grep -oE '"total_tokens"\s*:\s*[0-9]+' "$output_file" 2>/dev/null | tail -1 | grep -oE '[0-9]+') || total=0
            if [[ "$total" -gt 0 ]]; then
                # Estimate split if only total available
                input_tokens=$((total * 7 / 10))
                output_tokens=$((total * 3 / 10))
            fi
        fi
    fi

    # Ensure values are numeric
    input_tokens=${input_tokens:-0}
    output_tokens=${output_tokens:-0}
    [[ ! "$input_tokens" =~ ^[0-9]+$ ]] && input_tokens=0
    [[ ! "$output_tokens" =~ ^[0-9]+$ ]] && output_tokens=0

    # Calculate cost using model pricing
    # Default to Claude Sonnet pricing: $3/1M input, $15/1M output
    local input_rate=3.00
    local output_rate=15.00

    # Try to read from model_pricing.json if available
    local pricing_file="./$MARGE_FOLDER/model_pricing.json"
    [[ ! -f "$pricing_file" ]] && pricing_file="$MARGE_HOME/shared/model_pricing.json"

    if [[ -f "$pricing_file" ]] && command -v jq &>/dev/null; then
        local model_name="Claude Sonnet"
        [[ "$MODEL" == *"opus"* ]] && model_name="Claude Opus"
        local rates
        rates=$(jq -r --arg m "$model_name" '.models[] | select(.name | contains($m)) | "\(.input_per_1m) \(.output_per_1m)"' "$pricing_file" 2>/dev/null | head -1) || true
        if [[ -n "$rates" ]]; then
            input_rate=$(echo "$rates" | awk '{print $1}')
            output_rate=$(echo "$rates" | awk '{print $2}')
        fi
    fi

    if [[ $input_tokens -gt 0 ]] || [[ $output_tokens -gt 0 ]]; then
        local cost
        cost=$(awk -v it="$input_tokens" -v ot="$output_tokens" -v ir="$input_rate" -v or="$output_rate" \
            'BEGIN {printf "%.4f", (it * ir + ot * or) / 1000000}')

        # Output format: input|output|summary (caller parses to update totals)
        echo "${input_tokens}|${output_tokens}| · ${input_tokens}/${output_tokens}tok · \$${cost}"
    else
        echo "0|0|"
    fi
}

get_changed_files() {
    local output_file="$1"
    local files=""

    if [[ -f "$output_file" ]]; then
        # Parse Claude's stream-json output for Write and Edit tool calls
        # Look for "tool":"Write" or "tool":"Edit" and extract file_path
        files=$(grep -oE '"tool"\s*:\s*"(Write|Edit)"[^}]*"file_path"\s*:\s*"[^"]+"|"file_path"\s*:\s*"[^"]+"[^}]*"tool"\s*:\s*"(Write|Edit)"' "$output_file" 2>/dev/null | \
            grep -oE '"file_path"\s*:\s*"[^"]+"' | \
            sed 's/"file_path"\s*:\s*"//;s/"$//' | \
            sort -u) || true
    fi

    echo "$files"
}

get_response_text() {
    local output_file="$1"
    local engine="${2:-claude}"
    local max_lines="${3:-20}"

    [[ ! -f "$output_file" ]] && return

    case "$engine" in
        claude)
            # Extract text from stream-json format
            # Look for text_delta content and concatenate
            grep -oE '"text"\s*:\s*"[^"]*"' "$output_file" 2>/dev/null | \
                sed 's/"text"\s*:\s*"//;s/"$//' | \
                sed 's/\\n/\n/g; s/\\t/\t/g; s/\\"/"/g; s/\\\\/\\/g' | \
                tail -n "$max_lines"
            ;;
        *)
            # For other engines, just show raw output
            tail -n "$max_lines" "$output_file" 2>/dev/null
            ;;
    esac
}

build_engine_cmd() {
    local engine="$1"
    local prompt="$2"
    case "$engine" in
        claude)
            # -p requires prompt immediately after, other flags come before or after
            # --output-format stream-json requires --verbose when using -p
            echo -n "claude --dangerously-skip-permissions --verbose --output-format stream-json"
            [[ -n "$MODEL" ]] && echo -n " --model $MODEL"
            echo -n " -p"
            ;;
        opencode)
            echo -n "opencode --approval-mode full-auto"
            [[ -n "$MODEL" ]] && echo -n " --model $MODEL"
            ;;
        codex)
            echo -n "codex exec --full-auto"
            ;;
        aider)
            echo -n "aider --yes --message"
            [[ -n "$MODEL" ]] && echo -n " --model $MODEL"
            ;;
    esac
}

auto_commit() {
    [[ "$AUTO_COMMIT" != true ]] && return 0
    git rev-parse --git-dir &>/dev/null || return 0
    git add . 2>/dev/null || true
    git commit -m "Marge auto iteration $1" 2>/dev/null || true
}

is_task_complete() {
    local tasklist="./$MARGE_FOLDER/tasklist.md"
    local assessment="./$MARGE_FOLDER/assessment.md"

    [[ -f "$tasklist" ]] && grep -q "\[ \]" "$tasklist" && return 1
    [[ -f "$assessment" ]] && grep -iqE "(clean|complete|no issues)" "$assessment" && return 0
    return 0
}

parse_prd() {
    local file="$1"
    [[ ! -f "$file" ]] && return 1

    grep -E "^### " "$file" | sed 's/^### //' | sed 's/^Task [0-9]*: //'
}

run_task() {
    local task="$1" num="${2:-1}" workdir="${3:-.}"
    local task_start_time
    task_start_time=$(date +%s)

    # Only show task info in verbose mode - spinner shows task info
    log_debug "Task $num: $task"

    # Determine which AGENTS.md to use: local .marge/, global full, or lite for one-off tasks
    local agents_path="$workdir/$MARGE_FOLDER/AGENTS.md"
    local use_lite=false

    if [[ ! -f "$workdir/$MARGE_FOLDER/AGENTS.md" ]]; then
        if [[ "$MARGE_FOLDER" == ".marge" ]]; then
            if [[ "$FULL_MODE" == true ]] && [[ -f "$MARGE_HOME/shared/AGENTS.md" ]]; then
                # --full flag: use global full AGENTS.md
                agents_path="$MARGE_HOME/shared/AGENTS.md"
                log_debug "Using global AGENTS.md (--full mode)"
            elif [[ -f "$MARGE_HOME/AGENTS-lite.md" ]]; then
                # Default: use lite version for one-off tasks - much lower token cost
                agents_path="$MARGE_HOME/AGENTS-lite.md"
                use_lite=true
                log_debug "Using AGENTS-lite.md for one-off task"
            fi
        elif [[ "$MARGE_FOLDER" != ".marge" ]]; then
            log_error "Folder '$MARGE_FOLDER' not found or missing AGENTS.md"
            return 1
        fi
    fi

    # Only save progress for project tasks (not one-off lite tasks)
    [[ "$use_lite" != true ]] && save_progress "$num" "running"

    local loop_suffix=""
    [[ "$LOOP" == true ]] && loop_suffix=" Loop until complete." || true

    local prompt
    if [[ "$use_lite" == true ]]; then
        prompt="ONE-OFF TASK. You get ONE response to the user. No follow-ups, no clarifications. Be concise and direct.

Task: ${task}${loop_suffix}"
    elif [[ "$FULL_MODE" == true ]] && [[ ! -f "$workdir/$MARGE_FOLDER/AGENTS.md" ]]; then
        prompt="Read the AGENTS.md file at $agents_path and follow it.

Instruction:
- ${task}${loop_suffix}"
    else
        prompt="Read the AGENTS.md file in the $MARGE_FOLDER folder and follow it.

Instruction:
- ${task}${loop_suffix}

After finished, list remaining unchecked items in $MARGE_FOLDER/tasklist.md."
    fi

    if [[ "$DRY_RUN" == true ]]; then
        echo "${CYAN}Would run:${RESET} $(build_engine_cmd "$ENGINE") \"<prompt>\""
        return 0
    fi

    local cmd
    cmd=$(build_engine_cmd "$ENGINE")
    local retry=0
    local output_file="/tmp/marge_output_$$.txt"
    local ai_pid

    while [[ $retry -lt $MAX_RETRIES ]]; do
        log_debug "Attempt $((retry+1))/$MAX_RETRIES"
        log_debug "Command: $cmd \"<prompt>\""
        log_debug "Workdir: $workdir"

        # Run AI command in background with new session, no stdin (prevents direct tty writes)
        setsid bash -c "cd \"$workdir\" && $cmd \"\$1\" > \"$output_file\" 2>&1" -- "$prompt" </dev/null &
        ai_pid=$!
        log_debug "Started PID: $ai_pid"

        # Show spinner while AI is running (this is the only visible output during execution)
        show_spinner "$output_file" "$task" "$ai_pid"

        # Wait for AI and get exit status
        wait "$ai_pid"
        local exit_code=$?
        log_debug "Exit code: $exit_code"

        # Show output only in verbose mode
        if [[ -f "$output_file" ]] && [[ -s "$output_file" ]]; then
            [[ "$VERBOSE" == true ]] && cat "$output_file"
            log_debug "Output file size: $(wc -c < "$output_file") bytes"
        else
            log_debug "Output file empty or missing"
        fi

        if [[ $exit_code -eq 0 ]]; then
            local task_end_time
            task_end_time=$(date +%s)
            local task_duration=$((task_end_time - task_start_time))
            local duration_mins=$((task_duration / 60))
            local duration_secs=$((task_duration % 60))

            # Single completion line with all info
            local token_result token_info=""
            token_result=$(get_token_summary "$output_file")
            # Parse: input|output|summary
            local task_input task_output
            task_input=$(echo "$token_result" | cut -d'|' -f1)
            task_output=$(echo "$token_result" | cut -d'|' -f2)
            token_info=$(echo "$token_result" | cut -d'|' -f3-)
            # Accumulate totals
            total_input_tokens=$((total_input_tokens + task_input))
            total_output_tokens=$((total_output_tokens + task_output))
            echo "${GREEN}✓${RESET} Task $num done ${CYAN}${duration_mins}m${duration_secs}s${RESET}${token_info}"

            # Show changed files from Claude's output (works without git)
            local all_changes
            all_changes=$(get_changed_files "$output_file")

            if [[ -n "$all_changes" ]]; then
                local count
                count=$(echo "$all_changes" | wc -l)
                echo "  ${CYAN}Files changed (${count}):${RESET}"
                echo "$all_changes" | head -15 | while IFS= read -r file; do
                    if [[ -n "$file" ]]; then
                        echo "    ${YELLOW}•${RESET} $file"
                    fi
                done
            else
                # No files changed - show the response text instead
                local response_text
                response_text=$(get_response_text "$output_file" "$ENGINE" 20)
                if [[ -n "$response_text" ]]; then
                    echo "  ${CYAN}Response:${RESET}"
                    echo "$response_text" | while IFS= read -r line; do
                        echo "    $line"
                    done
                else
                    echo "  ${CYAN}No files changed${RESET}"
                fi
            fi

            auto_commit "$num"
            [[ "$use_lite" != true ]] && save_progress "$num" "completed"
            rm -f "$output_file"
            return 0
        fi

        ((++retry))
        [[ $retry -lt $MAX_RETRIES ]] && sleep "$RETRY_DELAY"
    done

    [[ "$use_lite" != true ]] && save_progress "$num" "failed"
    log_error "Task failed after $MAX_RETRIES retries"
    rm -f "$output_file"
    return 1
}

run_task_parallel() {
    local task="$1" num="$2" slug="$3"
    local workdir

    workdir=$(setup_worktree "$slug") || {
        log_error "Failed to setup worktree for $slug"
        return 1
    }

    log_info "Running task $num in worktree: $workdir"
    run_task "$task" "$num" "$workdir"
}

run_prd() {
    local tasks=()
    local pids=()
    local project_type

    project_type=$(detect_project)
    log_debug "Detected project type: $project_type"

    while IFS= read -r task; do
        [[ -n "$task" ]] && tasks+=("$task")
    done < <(parse_prd "$PRD_FILE")

    local count=${#tasks[@]}

    if [[ $count -eq 0 ]]; then
        log_warn "No tasks in $PRD_FILE"
        return 0
    fi

    # Minimal header
    echo "${BOLD}Marge v$VERSION${RESET} · ${count} tasks"

    if [[ "$DRY_RUN" == true ]]; then
        echo "${BOLD}Tasks:${RESET}"
        for i in "${!tasks[@]}"; do
            echo "  $((i+1)). ${tasks[$i]}"
        done
        return 0
    fi

    if [[ "$PARALLEL" == true ]]; then
        local running=0
        for i in "${!tasks[@]}"; do
            local task="${tasks[$i]}"
            local num=$((i+1))
            local slug
            slug=$(slugify "$task")

            while [[ $running -ge $MAX_PARALLEL ]]; do
                wait -n 2>/dev/null || true
                ((running--))
            done

            run_task_parallel "$task" "$num" "$slug" &
            pids+=($!)
            ((++running))
        done

        for pid in "${pids[@]}"; do
            wait "$pid" 2>/dev/null || true
        done

        cleanup_worktrees
    else
        for task in "${tasks[@]}"; do
            ((++iteration))

            if [[ "$BRANCH_PER_TASK" == true ]]; then
                local slug
                slug=$(slugify "$task")
                git checkout -b "marge/$slug" 2>/dev/null || git checkout "marge/$slug" 2>/dev/null || true
            fi

            run_task "$task" "$iteration" || { [[ "$LOOP" != true ]] && break; }

            is_task_complete && break
            [[ $iteration -ge $MAX_ITER ]] && { log_warn "Max iterations"; break; }
        done
    fi

    if [[ "$CREATE_PR" == true ]]; then
        log_debug "Creating PR..."
        local pr_title="Marge: Completed $iteration tasks"
        local pr_body="Automated PR by marge v$VERSION"
        gh pr create --title "$pr_title" --body "$pr_body" 2>/dev/null || log_warn "PR creation failed"
    fi

    clear_progress
    echo ""
    print_session_summary "$iteration"
    notify_done "Completed $iteration tasks"
}

print_session_summary() {
    local iter_count="${1:-0}"
    local session_end_time
    session_end_time=$(date +%s)
    local total_duration=$((session_end_time - session_start_time))
    local total_mins=$((total_duration / 60))
    local total_secs=$((total_duration % 60))

    echo "${BOLD}═══════════════════════════════════════════════════${RESET}"
    echo "${BOLD}Session Summary${RESET}"

    if [[ $total_input_tokens -gt 0 ]] || [[ $total_output_tokens -gt 0 ]]; then
        # Calculate total cost
        local input_rate=3.00
        local output_rate=15.00

        local pricing_file="./$MARGE_FOLDER/model_pricing.json"
        [[ ! -f "$pricing_file" ]] && pricing_file="$MARGE_HOME/shared/model_pricing.json"

        if [[ -f "$pricing_file" ]] && command -v jq &>/dev/null; then
            local model_name="Claude Sonnet"
            [[ "$MODEL" == *"opus"* ]] && model_name="Claude Opus"
            local rates
            rates=$(jq -r --arg m "$model_name" '.models[] | select(.name | contains($m)) | "\(.input_per_1m) \(.output_per_1m)"' "$pricing_file" 2>/dev/null | head -1) || true
            if [[ -n "$rates" ]]; then
                input_rate=$(echo "$rates" | awk '{print $1}')
                output_rate=$(echo "$rates" | awk '{print $2}')
            fi
        fi

        local total_cost
        total_cost=$(awk -v it="$total_input_tokens" -v ot="$total_output_tokens" -v ir="$input_rate" -v or="$output_rate" \
            'BEGIN {printf "%.4f", (it * ir + ot * or) / 1000000}')

        echo "  ${CYAN}Tokens:${RESET} ${total_input_tokens} in / ${total_output_tokens} out"
        echo "  ${CYAN}Cost:${RESET} \$${total_cost}"
    fi

    echo "  ${CYAN}Duration:${RESET} ${total_mins}m ${total_secs}s"
    echo "  ${CYAN}Iterations:${RESET} $iter_count"
    echo "${BOLD}═══════════════════════════════════════════════════${RESET}"
}

run_single() {
    local -a tasks=("$@")
    local task_count=${#tasks[@]}

    # Determine which agents file will be used
    local agents_label="AGENTS.md"
    if [[ ! -f "./$MARGE_FOLDER/AGENTS.md" ]] && [[ "$MARGE_FOLDER" == ".marge" ]]; then
        if [[ "$FULL_MODE" == true ]]; then
            agents_label="full"
        else
            agents_label="lite"
        fi
    fi

    # Header with version, agents file, and task count if multiple
    if [[ $task_count -gt 1 ]]; then
        echo "${BOLD}Marge v$VERSION${RESET} · ${CYAN}${agents_label}${RESET} · ${task_count} tasks"
    else
        echo "${BOLD}Marge v$VERSION${RESET} · ${CYAN}${agents_label}${RESET}"
    fi

    for task in "${tasks[@]}"; do
        ((++iteration))
        if [[ "$LOOP" == true ]]; then
            local loop_iter=0
            while [[ $loop_iter -lt $MAX_ITER ]]; do
                ((++loop_iter))
                run_task "$task" "$iteration" || true
                is_task_complete && break
                sleep 1
            done
        else
            run_task "$task" "$iteration"
        fi
    done

    echo ""
    print_session_summary "$iteration"
    notify_done "Task complete"
}

init_config() {
    local force_flag=""
    [[ "${1:-}" == "--force" ]] && force_flag="--force"

    # Use marge-init for full setup
    if ! "$MARGE_HOME/marge-init" $force_flag; then
        log_error "Failed to initialize .marge/"
        return 1
    fi

    # Create config.yaml if it doesn't exist
    if [[ ! -f ".marge/config.yaml" ]]; then
        cat > .marge/config.yaml <<EOF
engine: claude
model: ""
max_iterations: 20
max_retries: 3
auto_commit: false
EOF
    fi

    # Create PRD.md template if it doesn't exist
    [[ ! -f "PRD.md" ]] && cat > PRD.md <<'EOF'
# PRD

### Task 1: Setup
- [ ] Initialize project

### Task 2: Implementation
- [ ] Build features

### Task 3: Testing
- [ ] Write tests
EOF

    log_success "Initialized .marge/"
}

# Load config before parsing args (CLI overrides config)
load_config

# Parse args
POSITIONAL=()
while [[ $# -gt 0 ]]; do
    # shellcheck disable=SC2034,SC2015  # SC2034: AUTO/FAST reserved for future; SC2015: intentional || fallback
    case "$1" in
        --auto) AUTO=true; shift ;;
        --dry-run) DRY_RUN=true; shift ;;
        --model) MODEL="$2"; shift 2 ;;
        --engine) ENGINE="$2"; shift 2 ;;
        --fast) FAST=true; shift ;;
        --full) FULL_MODE=true; shift ;;
        --loop) LOOP=true; shift ;;
        --max-iterations) MAX_ITER="$2"; shift 2 ;;
        --max-retries) MAX_RETRIES="$2"; shift 2 ;;
        --commit) AUTO_COMMIT=true; shift ;;
        --no-commit) AUTO_COMMIT=false; shift ;;
        --parallel) PARALLEL=true; shift ;;
        --max-parallel) MAX_PARALLEL="$2"; shift 2 ;;
        --branch-per-task) BRANCH_PER_TASK=true; shift ;;
        --create-pr) CREATE_PR=true; shift ;;
        --folder) MARGE_FOLDER="$2"; shift 2 ;;
        -v|--verbose) VERBOSE=true; shift ;;
        --version) echo "marge $VERSION"; exit 0 ;;
        -h|--help|help) print_usage; exit 0 ;;
        meta)
            MARGE_FOLDER=".marge/meta"
            shift
            ;;
        init)
            shift
            init_config "$@"
            exit 0
            ;;
        clean)
            # Remove local .marge/ folder (not global MARGE_HOME)
            local_marge="$(pwd)/.marge"
            if [[ "$local_marge" == "$MARGE_HOME" ]]; then
                log_error "Cannot clean global MARGE_HOME ($MARGE_HOME)"
                log_error "Run from a project directory, not ~"
                exit 1
            elif [[ ! -d ".marge" ]]; then
                log_info "No .marge/ folder found in $(pwd)"
                exit 0
            else
                rm -rf .marge
                log_success "Removed local .marge/ folder"
                exit 0
            fi
            ;;
        status)
            echo "${BOLD}Marge Status${RESET}"
            echo "Project type: $(detect_project)"
            [[ -f "$PROGRESS_FILE" ]] && {
                echo "Progress file: $PROGRESS_FILE"
                cat "$PROGRESS_FILE"
            } || echo "No active progress"
            [[ -f "$PRD_FILE" ]] && echo "PRD tasks: $(parse_prd "$PRD_FILE" | wc -l)"
            exit 0
            ;;
        config) [[ -f "$MARGE_FOLDER/config.yaml" ]] && cat "$MARGE_FOLDER/config.yaml"; exit 0 ;;
        resume)
            load_progress && {
                log_info "Resuming from iteration $iteration"
            } || log_warn "No progress to resume"
            shift
            ;;
        -*) log_error "Unknown: $1"; exit 1 ;;
        *) POSITIONAL+=("$1"); shift ;;
    esac
done

check_engine "$ENGINE" || exit 1

if [[ ${#POSITIONAL[@]} -gt 0 ]]; then
    run_single "${POSITIONAL[@]}"
else
    run_prd
fi
